<html>
<head><title>Linux by czep</title></head>
<body bgcolor=#aabbcc>

<h1>Linux</h1>

<h2>The Most Powerful Operating System on the Planet</h2>

<p>
Arguments used to justify the superiority of one operating system over another generally tend to reduce to expressions of personal taste which to innocent observers carry about the same weight as a Coke-or-Pepsi debate.  This particular cola war is made even more ridiculous by the fact that its participants are generally regarded to be rather on the fringe of the social spectrum.  The more you know about the OS wars - even the simple act of expressing that you have a "favorite" OS - suggests to others that you spend your time thinking about things that may not be altogether healthy.  It is widely acknowledged among naturalists that the geek - who will remain passive during many confrontational situations such as rush-hour traffic, bar fights, and sex - will, like a cornered hyena defending its territory, viciously attack any and all who dare challenge its favorite OS.  The ensuing fracas, while brutal to its participants, is viewed by others with the same fascination as might accompany a trip to the circus.

<p>
This is not to suggest that the OS wars are a mere spectator sport devoid of any real substance.  In fact, despite that this admission will expose me as one of the circus freaks, I believe that there is a great deal at stake in the current operating system discourse having profound social and political implications.  My choice of the word "powerful" to describe Linux is deliberate and has more than one meaning.  Not only is Linux powerful as an efficient, well-organized, and elegant operating system, easily adaptable to any number of electronic devices (including computers); Linux is also powerful as a major player in a socio-technical movement which has begun to highlight and challenge some of the most deeply rooted tenets of our social and political structure.

<p>
OK, in the words of Jimi Hendrix, "let's not get frantic now."  At this point, I hope I haven't scared off any but the most careless hyperlinker who found themselves here by miraculous accident.  My claim that Linux is the most powerful operating system on the planet is not the result of controlled laboratory experiments or randomly sampled interviews with operating system specialists; it is simply, when you get to the heart of the matter, just my opinion.  What follows is not so much an argument for the superiority of Linux, but rather, an explanation for how I - and here I believe I am one among many - came to feel this way about it.



<h3>A Brief (Personal) History of Computing</h3>

I came to computing rather late in life, I didn't start programming until I was eleven.  Although that might sound like an auspicious beginning whose logical result must have been to produce a legendary guru of indescribable talents, my intent in making such a statement is not to brag or assert my authority over others, but rather to call attention to a particular view of mine.  To most people today, and to you perhaps, eleven years old will seem like a very early age for someone to begin to understand a computer language.  I consider it a late start.  Since the use of computers has become and will continue to be central to human existence, why should it seem so unusual that young children learn how they work?  Babies begin to mimic spoken language in their second year and can acquire basic writing and reading skills by the time they reach five.  Why, then, is it such a foreign concept that young kids should learn to express themselves both with and to a computer?  We as adults have been taught to think that computers are advanced tools whose use cannot be understood until one has mastered calculus.  Nothing could be further from the truth.  Computers are basic tools.  As basic as pencils, paper, numbers, and letters.  I have yet to find one introduction to computer science course that could not be readily imparted to the average fourth grade class.

<p>
It was in the fourth grade that I saw a real computer for the first time.  I say "real" because, growing up in the United States, computers have been an integral part of my society since the 1940s.  The day I was born, my vital statistics were entered by hospital administrators into a computer, my social security card was printed from a database residing on a computer, the bill for bringing me into the world was sent to my parents by a computer, and even then no doubt, the draft board, the IRS, the FBI, and various other three letter agencies, were notified of my newly discovered existence, and all that information was being stored somewhere in a computer.  And even though the details of all this were oblivious to me as a nine year old, by that time I had already been extensively exposed to computers as they were conceived in the popular imagination - in literature, movies, and the media.  The first time I saw a real computer was in a demonstration that was brought to my fourth grade class by a cadre of computer enthusiasts from NASA.  It was a TRS-80 Model 3.

<p>
Now, some of you in my listening audience, when thinking back to the first computer you ever sat down in front of, will recall something on the order of a PDP-6, occupying a space larger than most Manhattan studio apartments and with air conditioners so loud you'd swear the thing was about to take off into space, while others of you will think back fondly of the Pentium Pro system that your parents picked up one day from CompUSA, bundled with Windows 95, and including a free game pack or other assortment of educational software.  For me, that first computer was a TRS-80.  I sat down in front of the black-and-white console display, which asked me one simple question: what is your weight?  And when I hit the enter key, the sleek black box then quickly revealed to me how much I would weigh on Mercury.  And on Venus!  And on Mars, then Jupiter, and it didn't stop until I was told how much gravitational force I would exert on each of the nine planets in the solar system!  And it did all of this within a fraction of a second.  This was just a simple math problem of course, simpler than the ones we would encounter as word problems in our textbooks, but the computer solved nine of these simple math problems long before I would even be able to enter the first digit on a calculator.  For the first time, divorced of the associations given to computers by popular science fiction, I was given a glimpse of the true impact these machines could have.  The NASA folks knew what they were doing when they showed these things off.

<p>
It wasn't for another two years that I would first learn how to program a computer.  One day in sixth grade we came to class to find that our science teacher had been given, on loan from the local university, a collection of computers for us to use for the rest of the year:  a Texas Instruments TI-99/4A, a Sinclair ZX-81, and yes, another TRS-80 Model 3.  That year we learned LOGO (Turtle Power!!) and one of our first projects was to write a version of Snake - a fun little game in which you guide a snake around the screen to pick up food until the snake gets too big that it eventually runs into its tail.  Later that year, my parents bought one of the original IBM PCs with its classic green screen.  It had no hard disk, but relied on its 5 1/4 inch floppy disk drive to load MS-DOS version 3.0 into its whopping 64K of main memory.  And on this beauty, I learned BASIC.  It's been a long time since I wrote code with line numbers and goto statements, but those early days with the IBM PC were the foundation of my life as a programmer, and I might add, of my love for the command line.

<p>
Before I paint myself into a cubicle, let me state that my life has not been one of non-stop hacking since the sixth grade - I actually took some time now and then to get a life.  I read books.  I played baseball.  I had a social life.  In college I majored in one of the "soft sciences" which, though often maligned, was for me a far better education than I would have received in a pure engineering or computer science course of study.  There are, believe it or not, a good many important things that have happened in the history of our world that don't involve computers, and you just might learn something new if you can tear yourself away from your perl scripts once in awhile.  End of lesson.  In any case, ever since I got my first taste of what it was to program, I have always drifted, often by necessity but mainly out of an unending curiosity and sense of excitement, back to the world of computers.

<h3>Phoning Home</h3>

Among other discoveries that awaited me at college, one of the most fabulous was that I could talk with my friends, many of whom were on distant shores, without having to pay a dime to the phone company and without having to wait for the postal system to lose my mail.  Back in those freewheeling days of the internet, when everything ended with .edu or .mil, talk daemons weren't considered security risks and you could actually finger remote hosts to see if your friends were logged on.  Then, there was no AOL, no Instant Messenger, nor even a World Wide Web, but all of these things were made possible because of a few well-designed communications protocols, a physical network once known as ARPANET, and of course, computers running the UNIX operating system.

<p>
The key design advantage of UNIX is that it was built from the beginning for multiuser, multitasking, networked environments whereas "personal" computer operating systems like DOS, Windows, and the Mac OS, were designed to run on single user, single-task, stand-alone machines.  And even though personal computers were able to connect to local area networks, all of the programs that handled communications - email, messenger, ftp, gopher - were executing on UNIX computers.  The PC operating system gave you just enough functionality to connect to a UNIX machine somewhere on your network, and from there you could go where you pleased.

<p>
This is not to say it was always easy.  For three weeks, I wrote emails from a terminal that would echo each character I typed, because I kept using the wrong connection settings on the telnet program in the computer lab!  Learning command line options for various tasks was a journey into a strange nether-world of bizarre syntactic rules.  It was very easy to "do" something and not really know what you did, or how to "undo" it.  I was once fiercely rebuked for ignorantly leaving a CPU-intensive program running for four days.  Nowadays, user processes normally die when one logs out, but then the sysadmins had no reason to include such restrictions, assuming that the average user knew how to ps, fg, and kill -9.  The only available help feature, the man pages, while an absolute godsend, generally gave you just enough information to either thoroughly confuse you or scare you to death.  And learning the theory of UNIX, what things it did and how it got those things done, was a truly bewildering experience for someone coming from personal computer operating systems.  All the talk of kernels, pipes, and semaphores - it sounded more to me like a naval installation than a computer.

<p>
Still, those trial-and-error sessions, while often painful and frustrating, were ultimately enormously rewarding.  To finally grasp this or that aspect of the system, no matter how trivial, brought a feeling of epiphany so strong it would have brought James Joyce himself to tears.  Because what I came to see was what the designers of the system had intended.  Beneath the cryptic commands and the funny terminology, the way in which UNIX worked was intelligently and elegantly authored.  This joyous feeling of discovery and comprehension was the same thing that inspired me about computers in the first place.  A problem, an algorithm, and a solution expressed essentially as a work of art.

<p>
The problem at the time was that you couldn't run UNIX on a personal computer.  Not only was it written for an entirely different hardware architecture, but it was also very very expensive.  So in the meantime, there was the Mac OS, DOS, and later Windows.  I had a Mac in college because it was a little prettier than Windows, and much easier to network on our campus.  At the time, Apple was the dominant platform for the desktop/personal computer, but the Mac was in its waning days, and the tell-tale signs were evident.  Apple didn't license its hardware specifications.  When IBM did, and cheap PC clones based on generic x86 architecture flooded the market, the end was near for the Mac.  And after college, when I entered the "real world" to work at a software company, the sleeping giant of Redmond had long since been awakened.

<h3>Windows To The World</h3>

For me, learning and using the various flavors of Windows, were, sadly, not filled with the same excitement and wonder that I had experienced with UNIX.  I know others have different opinions.  NT has come close to the mark, but rarely - very rarely - have I ever felt that the NT implementation of some problem was elegant.  And most often, I found that it was either broken or an ugly kludge of something UNIX had been doing well for a good quarter century before.  But Microsoft was rapidly gaining something that would ultimately become far more important than elegance: marketshare.

<p>
Naturally, explaining Microsoft's rise to power involves a complex set of factors, and I can't fully do justice to the situation here.  Of the many variations of DOS, MS-DOS was by far the most successful and the choice for IBM's PCs in the 1980s.  These computers were based on the x86 architecture by Intel and were inexpensive to produce in mass quantities.  When this architecture was opened via license to other computer manufacturers (as opposed to Apple who retained exclusive rights to manufacture the hardware on which their OS would run), intense competition lowered the prices on these computers very rapidly.  Partially as a result of these lowered costs, the demand for personal computers in the early 1990s sky-rocketed.  Since MS-DOS was already a de facto standard on these PCs, Microsoft licensed Windows to x86 computer manufacturers who supplied them to the public who were willing to pay a little extra in exchange for not having to write their own operating system for the computer.  And thus was sealed Microsoft's success in the desktop market.

<p>
When all of this was happening, UNIX continued to thrive, despite having been fractured into numerous competing flavors, because the heavy-duty work of large organizations continued to be tended to by heavy-duty computers running UNIX.  Databases and accounting applications, scientific programs, and of course networking, were all still done on UNIX machines to which networked PCs would connect.  What Microsoft and cheap x86-based computers enabled people to do was have a nice looking interface on their desktop that would enable them to write memos, play solitaire, and connect to their UNIX machines when they needed to do some heavy-duty work.  I should also mention that while all of this was happening, Linus Torvalds and his band of merry men, were already in full action and rapidly making waves in various small corners of the world.  Because what Linus had managed to do, with a great deal of help from others like GNU and the Free Software Foundation, was write a UNIX-like operating system for the x86 personal computer.  In the meantime however, corporate America discovered Word and Excel.  And standardized quickly.  I would argue that without the widespread adoption of these two programs, Microsoft would not be a recognizable name.

<p>
Central to Microsoft's success is the fact that they do not release the source code for Windows.  They do, however, license the application programming interface - the general structure of the functions that make the operating system work - to other companies for a dear fee.  However, given that they alone have exclusive access to the source code of their operating system, they are in a unique position to write software that works in near-perfect accord with the operating system.  Nobody else can do it as well as they can, even those with access to the API functions.  Furthermore, since there are many functions that remain undocumented, Microsoft is able to write software for their operating system that gives them a clear advantage over competitors.  Hence, the demise of WordPerfect and Lotus 1-2-3.

<p>
I do not mean to imply, however, that this is the only reason for the widespread adoption of Word and Excel.  Well, maybe for Word but this is definitely not the case with Excel.  Let me take a timeout to say that Excel is one of the best applications in the history of applications.  I publicly congratulate Microsoft for taking the spreadsheet concept and turning it into a killer app.  Working with Excel, I do feel that epiphanic sense of joy and wonder that is so enticing and rewarding.  Excel is rich in features, incredibly versatile, has an intuitive interface (especially the VBA IDE) and is easily extensible with Visual Basic.  I have never, not once, had Excel crash except when it was running code that I or someone else had written in VBA.  I'll go so far as to say that if they could do something about that 255 column limit per worksheet, there'd be no need for Oracle, let alone Access.  And no one has come close to competing with Excel.  The open-source alternatives, while a good start, have a long long way to go.  As a software developer, using Excel as the development platform is almost a no-brainer.  The GUI framework is built in as are an incredible assortment of library functions for everything from statistical manipulation to string processing.  Dude, it rocks.  And what's more, I can be guaranteed that almost everyone will be able to run programs written in VBA for Excel.  If you personally don't have Excel on your desktop, you're no more than 100 feet away from someone who does.  Guaranteed.

<p>
The problems that Excel does have have less to do with the application itself than they do with Windows.  The majority of problems I've had with VBA code in Excel are caused by the poor implementation of the shared library functions that make up the bulk of Windows functionality.  For this reason, I also cannot tolerate Visual C++.  It is, simply, an abomination.  LISP has more in common with C than does VC++.  Win32 programming is a new plane of hell.  And the MFC make win32 look like good old LOGO.  I personally think it's moronic to devote any significant chunk of one's life to learning how to write C/C++ code for Windows (my sincerest apologies to Mr. Petzold, who tried).  Not only are the eccentricities of the Windows API enough of an obstacle, but Visual Basic is just as good of an alternative for any Windows application - and it's infinitely easier to learn and use.  You laugh?  With a few tricks, VB code runs faster than VC++ compiled executables.  And even unoptimized VB code doesn't suffer from that much of a performance degradation.  So, really, why go through all the trouble?  If you need C, and often times you do, then you don't need Windows.  Visual Basic wins because it's fast and versatile.  Still, I wouldn't trust it with the fate of the world or air traffic control systems, and if my wristwatch ran on VB code, I'd double check with an analog clock every now and then, but for most daily business and/or general interest programming, where a quick solution is more important than a bullet-proof application, VB works fine.

<p>
Or, I should say, has worked fine until now.  I say this because I feel that the utility of Visual Basic, and of all the Office products which it glues together, is not going to excel (pun intended) much longer.  I do not anticipate the .NET strategy will work for Microsoft.  Early reports indicate that the new version of Visual Basic is but a bastardized cousin of its former self.  I think the fundamental problem lies in the fact that Microsoft is going too far in trying to co-opt the server market.  Ten years ago, the idea that Microsoft software would be run on servers would have been laughable, in much the same way as it would be similarly unthinkable that UNIX would run on a personal computer.  And while the latter feat has been successfully accomplished, there is still a great deal of resistance to Microsoft products as large-scale enterprise solutions.  Microsoft has been able to overcome much of the resistance by responding with intensive marketing efforts, tactical licensing agreements, and of course, leveraging their position as the dominant desktop operating system to make inroads in the server arena.

<p>
Companies reinvent themselves all the time, and in technology, this process occurs at a faster rate than in most industries.  Success in one sector of the market makes it easier to extend into other sectors.  Hence, Microsoft, which began with a version of the BASIC programming language written for the Altair, moved into operating systems with MS-DOS.  Then, with the success of Windows, moved into the application software business.  Now, with 90% marketshare of personal computer operating systems, there is virtually no more room to move up, so it has to move out.  Out into the server market and the embedded systems market.  The success Microsoft has enjoyed so far in the server market has been partially well deserved.  Prior to the development of their NT operating system, which became roughly stable enough for serious enterprise computing with version 4.0, they  licensed NT Server for a fraction of the cost of commercial UNIX licenses.  Coupled with the fact that NT would run on souped-up x86 machines, which were themselves much cheaper than the hardware used by Sun, DEC, HP, IBM, SGI, etc., people could buy mid-range servers at about half the price of a machine outfitted with UNIX.  It was smart, not only for Microsoft but for the consumer as well, and it gave a judicious kick to the commercial UNIX vendors who'd smugly thought they'd had the market cornered.  Now, however, the rapid adoption of Linux has offered up another alternative, one which can easily undercut both the commercial UNIX vendors and Microsoft - because the operating system itself is free.

<h3>Free Speech, Free Beer</h3>

To the unannointed masses, the word 'free' seems to have a very simple meaning.  We all know what it means to be free, right?  Likewise, we all know - or think we know - what it means to have our freedom taken away.  However, in various circles - among philosophers or software engineers for example - freedom is a heavily loaded concept that requires very careful attention.  One of the first qualifications to the idea of freedom one may encounter in a class on the history of philosophy is that there are two very different types of freedoms:  freedom "from" and freedom "to".  Freedom from persecution based on sex, race, religion, or operating system preference is of a different class than is the freedom to speak, to dance, or to reverse engineer an encryption scheme.  The first type of freedom defines the limits of the actions of others applied to the individual, whereas the second type of freedom defines the scope of the individual's actions applied to others.  
<p>
In software circles, the central distinction that needs to be made about freedom is whether something is free-as-in-speech or free-as-in-beer.  These two meanings are both of fundamental importance.  When software is free-as-in-beer, it costs nothing.  When software is free-as-in-speech, the code itself is public domain, meaning that anyone can use it, change it, or redistribute it in any form, PROVIDED THAT IT REMAINS FREE.  Thus, software as "free speech" places a distinct limit on what you are free to do with it.  You are free to distribute it; you are free to charge money for it; but, you are not free to close the source code.  This is the hallmark of the GNU General Public License and may very well be the most revolutionary concept of our times.

<p>
The Linux operating system is distributed under the GNU General Public License and as such is free software.  You - yes you - are free to download the actual source code to Linux, to change it howsoever you see fit, and to redistribute it with or without a fee.  The only proviso, however, is that the source code remain open.  This model also applies to the vast amount of software that has been written to run on Linux:  system commands, communications programs, databases, compilers, editors, multimedia and office productivity applications, device drivers, file systems, and graphical user interface libraries.  A complete system, including the operating system and everything you - yes you - could possibly conceive of running on a computer - are all available to you for free.

<p>
Working with Linux has rekindled the same fire I felt when I first discovered computer programming, the same joys I felt when I discovered UNIX, and, in addition, the same activism I felt when I took my first sociology class.  The success of Linux has hinged on the fact that thousands, if not millions, of programmers have assisted in its development.  One of the cruelest jokes you can play on a programmer is to give him or her a fresh new binary computer program without the source code.  Chances are they will play with it, pick at it, expose a few unforeseen bugs, but then grow frustrated at not being able to properly debug or extend it.  If, however, you give them the source code outright, they're certain to read it, experiment with it, and perhaps, implement a bug fix or add on some entirely new functionality to improve it.  This is the development model of choice - nay, of necessity - for those working with free software.  Not only does it utterly destroy the competitive advantage of commercial software because the number of developers is an order of magnitude higher, but because it inspires the individual programmer to make a contribution and to see their contribution benefit others.  Despite the claims of Jim Allchin - the Microsoft mogul who recently proclaimed open-source software to be un-American, it is this inspiration that is the true source of innovation.

<p>
For these reasons, I herald the growth of Linux as more than just the next fad.  Not only is it a revolutionary operating system because of its technical virtues, Linux is also at the forefront of a movement that has the power to alter some of the most deeply embedded assumptions of modern western capitalism.  The present day is riddled with buggy inferior software being peddled to individual consumers and large organizations alike by slick-talking salesmen with high visibility name-brands and armies of lawyers behind them.  Patents are issued daily for algorithms - common problem solving techniques - or for obvious business strategies which, because they involve computers, are somehow deemed novel and worthy of the same protection as physical property.  Companies sell expensive closed-source software to consumers and organizations who are then required to purchase expensive support contracts from those companies because, without the source code, they are unable to fix the software themselves.  Linux grants us the freedom from closed-source proprietary software, and gives us the freedom to design a world based on collective effort rather than corporate profit.  In the context of my own personal experience with computers as well as in terms of the current state of society, I can think of no better way to describe it:  Linux is the most powerful operating system on the planet.

<p>
<hr>


</body>
</html>
